#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from llama_index import SimpleDirectoryReader, LangchainEmbedding, GPTListIndex, GPTSimpleVectorIndex, PromptHelper
from langchain.embeddings.huggingface import HuggingFaceEmbeddings
from llama_index import LLMPredictor
import torch
from langchain.llms.base import LLM
from transformers import pipeline


class FlanLLM(LLM):
    model_name = "google/flan-t5-large"
    pipeline = pipeline("text2text-generation", model=model_name, device=0, model_kwargs={
        "torch_dtype": torch.bfloat16
    })

    def _call(self, prompt, stop=None):
        return self.pipeline(prompt, max_length=9999)[0]["generated_text"]

    def _identifying_params(self):
        return {"name_of_model": self.model_name}

    def _llm_type(self):
        return "custome"

llm_predictor = LLMPredictor(llm=FlanLLM())
hfemb = HuggingFaceEmbeddings()
embed_model = LangchainEmbedding(hfemb)

text1 = """
The execution plan is a description of the execution process of a SQL query statement in the database. Users can view the logical execution plan generated by the optimizer for the specified SQL using the EXPLAIN command.

To analyze the performance issues of a SQL statement, you usually need to first view the SQL execution plan and troubleshoot whether there are any problems in each step of the SQL execution. Therefore, understanding the execution plan is a prerequisite for SQL optimization, and understanding the operators of the execution plan is key to understanding the EXPLAIN command.

OceanBase database has three modes for the execution plan command: EXPLAIN BASIC, EXPLAIN, and EXPLAIN EXTENDED. These three modes show different granularities of detail information about the execution plan:

EXPLAIN BASIC command is used for the most basic plan display.

EXPLAIN EXTENDED command is used for the most detailed plan display (this display mode is usually used when troubleshooting issues).

EXPLAIN command shows information that helps ordinary users understand the execution method of the entire plan.

The format of the EXPLAIN command is as follows:
EXPLAIN [BASIC | EXTENDED | PARTITIONS | FORMAT = format_name] [PRETTY | PRETTY_COLOR] explainable_stmt
format_name:
{ TRADITIONAL | JSON }
explainable_stmt:
{ SELECT statement
| DELETE statement
| INSERT statement
| REPLACE statement
| UPDATE statement }

The EXPLAIN command is applicable to SELECT, DELETE, INSERT, REPLACE, and UPDATE statements, displaying information provided by the optimizer about the execution plan of the statement, including how to process the statement, how to join tables, and in what order to join tables.

In general, you can use the EXPLAIN EXTENDED command to display the range segments of table scans. The EXPLAIN OUTLINE command can be used to display Outline information.

The FORMAT option can be used to select the output format. TRADITIONAL means displaying output in table format, which is the default setting. JSON means displaying information in JSON format.

Using EXPLAIN PARTITIONS can also be used to check queries involving partitioned tables. If checking a query for a non-partitioned table, no error will be generated, but the value of the PARTITIONS column will always be NULL.

For complex execution plans, you can use the PRETTY or PRETTY_COLOR options to connect parent and child nodes in the plan tree with tree lines or colored tree lines, making the execution plan display easier to read. An example is as follows:
obclient> CREATE TABLE p1table(c1 INT ,c2 INT) PARTITION BY HASH(c1) PARTITIONS 2;
Query OK, 0 rows affected

obclient> CREATE TABLE p2table(c1 INT ,c2 INT) PARTITION BY HASH(c1) PARTITIONS 4;
Query OK, 0 rows affected

obclient> EXPLAIN EXTENDED PRETTY_COLOR SELECT  * FROM p1table p1 JOIN p2table p2 ON p1.c1=p2.c2\G
*************************** 1. row ***************************
Query Plan: ==========================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST|
----------------------------------------------------------
|0 |PX COORDINATOR               |        |1        |278 |
|1 | EXCHANGE OUT DISTR          |:EX10001|1        |277 |
|2 |  HASH JOIN                  |        |1        |276 |
|3 |  ├PX PARTITION ITERATOR     |        |1        |92  |
|4 |  │ TABLE SCAN               |P1      |1        |92  |
|5 |  └EXCHANGE IN DISTR         |        |1        |184 |
|6 |    EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |184 |
|7 |     PX PARTITION ITERATOR   |        |1        |183 |
|8 |      TABLE SCAN             |P2      |1        |183 |
==========================================================

Outputs & filters:
-------------------------------------
  0 - output([INTERNAL_FUNCTION(P1.C1, P1.C2, P2.C1, P2.C2)]), filter(nil)
  1 - output([INTERNAL_FUNCTION(P1.C1, P1.C2, P2.C1, P2.C2)]), filter(nil), dop=1
  2 - output([P1.C1], [P2.C2], [P1.C2], [P2.C1]), filter(nil),
      equal_conds([P1.C1 = P2.C2]), other_conds(nil)
  3 - output([P1.C1], [P1.C2]), filter(nil)
  4 - output([P1.C1], [P1.C2]), filter(nil),
      access([P1.C1], [P1.C2]), partitions(p[0-1])
  5 - output([P2.C2], [P2.C1]), filter(nil)
  6 - (#keys=1, [P2.C2]), output([P2.C2], [P2.C1]), filter(nil), dop=1
  7 - output([P2.C1], [P2.C2]), filter(nil)
  8 - output([P2.C1], [P2.C2]), filter(nil),
      access([P2.C1], [P2.C2]), partitions(p[0-3])

1 row in set 



 
## Execution Plan Shape and Operator Information
In database systems, execution plans are internally represented as trees, but different databases choose different ways to display them to users.

The following examples show the plan display for TPCDS Q3 in PostgreSQL database, Oracle database, and OceanBase database.

```sql
obclient> SELECT /*TPC-DS Q3*/ * 
     FROM (SELECT dt.d_year, 
                  item.i_brand_id    brand_id, 
                  item.i_brand       brand, 
                  Sum(ss_net_profit) sum_agg 
           FROM   date_dim dt, 
                  store_sales, 
                  item 
           WHERE  dt.d_date_sk = store_sales.ss_sold_date_sk 
                  AND store_sales.ss_item_sk = item.i_item_sk 
                  AND item.i_manufact_id = 914 
                  AND dt.d_moy = 11 
           GROUP  BY dt.d_year, 
                  item.i_brand, 
                  item.i_brand_id 
           ORDER  BY dt.d_year, 
                  sum_agg DESC, 
                  brand_id) 
     WHERE ROWNUM <= 100; 

PostgreSQL database execution plan display is as follows:
Limit  (cost=13986.86..13987.20 rows=27 width=91)
         Sort  (cost=13986.86..13986.93 rows=27 width=65)
         Sort Key: dt.d_year, (sum(store_sales.ss_net_profit)), item.i_brand_id
              HashAggregate  (cost=13985.95..13986.22 rows=27 width=65)
                     Merge Join  (cost=13884.21..13983.91 rows=204 width=65)
                     Merge Cond: (dt.d_date_sk = store_sales.ss_sold_date_sk)
                           Index Scan using date_dim_pkey on date_dim dt  (cost=0.00..3494.62 rows=6080 width=8)
                           Filter: (d_moy = 11)
                           Sort  (cost=12170.87..12177.27 rows=2560 width=65)
                           Sort Key: store_sales.ss_sold_date_sk
                                 Nested Loop  (cost=6.02..12025.94 rows=2560 width=65)
                                       Seq Scan on item  (cost=0.00..1455.00 rows=16 width=59)
                                       Filter: (i_manufact_id = 914)
                                       Bitmap Heap Scan on store_sales  (cost=6.02..658.94 rows=174 width=14)
                                       Recheck Cond: (ss_item_sk = item.i_item_sk)
                                             Bitmap Index Scan on store_sales_pkey  (cost=0.00..5.97 rows=174 width=0)
                                             Index Cond: (ss_item_sk = item.i_item_sk)



Oracle database execution plan display is as follows:
Plan hash value: 2331821367
--------------------------------------------------------------------------------------------------
| Id  | Operation                         | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |              |   100 |  9100 |  3688   (1)| 00:00:01 |
|*  1 |  COUNT STOPKEY                    |              |       |       |            |          |
|   2 |   VIEW                            |              |  2736 |   243K|  3688   (1)| 00:00:01 |
|*  3 |    SORT ORDER BY STOPKEY          |              |  2736 |   256K|  3688   (1)| 00:00:01 |
|   4 |     HASH GROUP BY                 |              |  2736 |   256K|  3688   (1)| 00:00:01 |
|*  5 |      HASH JOIN                    |              |  2736 |   256K|  3686   (1)| 00:00:01 |
|*  6 |       TABLE ACCESS FULL           | DATE_DIM     |  6087 | 79131 |   376   (1)| 00:00:01 |
|   7 |       NESTED LOOPS                |              |  2865 |   232K|  3310   (1)| 00:00:01 |
|   8 |        NESTED LOOPS               |              |  2865 |   232K|  3310   (1)| 00:00:01 |
|*  9 |         TABLE ACCESS FULL         | ITEM         |    18 |  1188 |   375   (0)| 00:00:01 |
|* 10 |         INDEX RANGE SCAN          | SYS_C0010069 |   159 |       |     2   (0)| 00:00:01 |
|  11 |        TABLE ACCESS BY INDEX ROWID| STORE_SALES  |   159 |  2703 |   163   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------

OceanBase database execution plan display is as follows:
|ID|OPERATOR              |NAME       |EST. ROWS|COST |
-------------------------------------------------------
|0 |LIMIT                 |           |100      |81141|
|1 | TOP-N SORT           |           |100      |81127|
|2 |  HASH GROUP BY       |           |2924     |68551|
|3 |   HASH JOIN          |           |2924     |65004|
|4 |    SUBPLAN SCAN      |VIEW1      |2953     |19070|
|5 |     HASH GROUP BY    |           |2953     |18662|
|6 |      NESTED-LOOP JOIN|           |2953     |15080|
|7 |       TABLE SCAN     |ITEM       |19       |11841|
|8 |       TABLE SCAN     |STORE_SALES|161      |73   |
|9 |    TABLE SCAN        |DT         |6088     |29401|
=======================================================

As can be seen from the examples, OceanBase database's plan display is similar to Oracle database.

The meanings of each column in OceanBase database execution plan are as follows:
Column Name Meaning
ID The serial number of the execution tree obtained by pre-order traversal (starting from 0).
OPERATOR The name of the operation operator.
NAME The table name (index name) for the corresponding table operation.
EST. ROWS The estimated number of output rows for this operation operator.
COST The execution cost of this operation operator (in microseconds).

The first part of the OceanBase database EXPLAIN command output is the tree structure display of the execution plan. The level of each operation in the tree is shown by its indentation in the operator column, with the deepest level executed first and the same level executed according to the execution order of specific operators.

Question: update a not exists (b…)
At first, I thought B was the driving table, and B had a lot of data. Later, I saw NLAJ, which means that the left table is associated with the right table.
So is the actual driving table A, using A to match B, is there any problem with this understanding?

Answer: That's right, A drives B.

Question: I just know that the table at the bottom right is the driving table, so I was a bit confused at first :sweat_smile:

Answer: The principle of nlj should be that the records of the left table (driving table) probe the right table (driven table). Which table becomes the left or right table is based on some other considerations, such as data volume. Anti join/semi join is just an optimization for not exist/exists, and the relevant principles and materials can be found online.

Question: So nlj is based on the previous understanding of who executes first, and the driving table is the table on the far right of the execution plan.
For anti join/semi join, the table on the left side of not exist is the driving table. Is this understanding correct?

Answer: nlj also has the left table as the driving table. You need to understand the basic principles of plan execution. Take a row of data from the left table and then traverse the right table. Once the join condition is satisfied, data can be returned.
Anti/semi joins are just because the semantics of not exists/exists only return left table data, and changing to anti join is a plan optimization. The join method is more efficient than subqueries.
""" 

from llama_index import Document
text_list = [text1]
documents = [Document(t) for t in text_list]

num_output = 250
max_input_size = 512

max_chunk_overlap = 20
prompt_helper = PromptHelper(max_input_size, num_output, max_chunk_overlap)

index = GPTListIndex(documents, embed_model=embed_model, llm_predictor=llm_predictor, prompt_helper=prompt_helper)
index.save_to_disk("index.json")


if __name__ == "__main__":
    import logging
    logging.getLogger().setLevel(logging.CRITICAL)
    for d in documents:
        print(d)

    response = index.query("How many database execution plan commands are there?")
    print(response)
